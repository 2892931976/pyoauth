#!/usr/bin/env python
# -*- coding: utf-8 -*-
# OAuth utility functions.
#
# Copyright (C) 2009 Facebook.
# Copyright (C) 2011 Yesudeep Mangalapilly <yesudeep@gmail.com>


import binascii
import time
import urlparse
import urllib
import uuid

try:
    from urlparse import parse_qs
except ImportError:
    from cgi import parse_qs


def url_equals(url1, url2):
    """
    Compares two URLs and determines whether they are the equal.

    :param url1:
        First URL.
    :param url2:
        Second URL.
    :returns:
        ``True`` if equal; ``False`` otherwise.
    """
    u1 = urlparse.urlparse(url1)
    u2 = urlparse.urlparse(url2)
    return u1.hostname == u2.hostname and \
        u1.password == u2.password and \
        u1.port == u2.port and \
        u1.username == u2.username and \
        u1.scheme == u2.scheme and \
        u1.path == u2.path and \
        u1.netloc == u2.netloc and \
        parse_qs(u1.query) == parse_qs(u2.query)


def url_concat(url, query_params=None):
    """
    Concatenate URL and query parameters regardless of whether
    the URL has existing query parameters.

    :param url:
        The URL to add the query parameters to.
    :param query_params:
        Query parameter dictionary.

    >>> url = url_concat("http://www.example.com/foo?a=b", dict(c="d"))
    >>> url_equals("http://www.example.com/foo?a=b&c=d", url)
    True

    >>> url = url_concat("http://www.example.com/", dict(c="d"))
    >>> url_equals("http://www.example.com/?c=d", url)
    True

    >>> url = url_concat("http://www.example.com/", dict(c="d"))
    >>> url_equals("http://www.example.com/?c=d", url)
    True

    >>> url = url_concat("http://www.example.com/foo?a=b", dict(a="d"))
    >>> url_equals("http://www.example.com/foo?a=b&a=d", url)
    True
    """
    if not query_params:
        return url
    if url[-1] not in ("?", "&"):
        url += "&" if ("?" in url) else "?"
    return url + urllib.urlencode(query_params)


def generate_nonce():
    """
    Calculates an OAuth nonce.

    Nonce and Timestamp (http://tools.ietf.org/html/rfc5849#section-3.3)
    --------------------------------------------------------------------
    A nonce is a random string, uniquely generated by the client to allow
    the server to verify that a request has never been made before and
    helps prevent replay attacks when requests are made over a non-secure
    channel.  The nonce value MUST be unique across all requests with the
    same timestamp, client credentials, and token combinations.

    :returns:
        A string representation of a randomly-generated hexadecimal OAuth nonce.
    """
    return binascii.b2a_hex(uuid.uuid4().bytes)


def generate_timestamp():
    """
    Generates an OAuth timestamp.

    Nonce and Timestamp (http://tools.ietf.org/html/rfc5849#section-3.3)
    --------------------------------------------------------------------
    The timestamp value MUST be a positive integer.  Unless otherwise
    specified by the server's documentation, the timestamp is expressed
    in the number of seconds since January 1, 1970 00:00:00 GMT.
    """
    return str(int(time.time()))


def oauth_escape(val):
    """
    Escapes the value of a query string parameter according to the OAuth spec.

    Percent Encoding (http://tools.ietf.org/html/rfc5849#section-3.6)
    -----------------------------------------------------------------
    Existing percent-encoding methods do not guarantee a consistent
    construction of the signature base string.  The following percent-
    encoding method is not defined to replace the existing encoding
    methods defined by [RFC3986] and [W3C.REC-html40-19980424].  It is
    used only in the construction of the signature base string and the
    "Authorization" header field.

    This specification defines the following method for percent-encoding
    strings:

    1.  Text values are first encoded as UTF-8 octets per [RFC3629] if
       they are not already.  This does not include binary values that
       are not intended for human consumption.

    2.  The values are then escaped using the [RFC3986] percent-encoding
       (%XX) mechanism as follows:

       *  Characters in the unreserved character set as defined by
          [RFC3986], Section 2.3 (ALPHA, DIGIT, "-", ".", "_", "~") MUST
          NOT be encoded.

       *  All other characters MUST be encoded.

       *  The two hexadecimal characters used to represent encoded
          characters MUST be uppercase.

    This method is different from the encoding scheme used by the
    "application/x-www-form-urlencoded" content-type (for example, it
    encodes space characters as "%20" and not using the "+" character).
    It MAY be different from the percent-encoding functions provided by
    web-development frameworks (e.g., encode different characters, use
    lowercase hexadecimal characters).

    :param val:
        Query string parameter value to escape.
    :returns:
        String representing escaped value.
    """
    if isinstance(val, unicode):
        val = val.encode("utf-8")
    return urllib.quote(val, safe="~")
